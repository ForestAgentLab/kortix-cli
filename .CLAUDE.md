# Kortix FastAPI 后端文档

> 本文档记录 Kortix CLI 的 FastAPI 后端接口规范和代码风格指南。

## 架构概览

### 技术栈
- **框架**: FastAPI 0.110+
- **Web 服务器**: Uvicorn
- **AI 模型**: 阿里云百炼 (Dashscope) - qwen-plus/qwen-max
- **沙箱环境**: Docker (代码执行)
- **数据验证**: Pydantic v2

### 架构设计
参考 [suna](https://github.com/kortix-ai/suna) 后端架构：
- **模块化路由**: 每个功能模块独立路由文件
- **异步优先**: 全异步 API 设计
- **流式响应**: 支持 Server-Sent Events (SSE)
- **CORS 支持**: 允许前端跨域访问

### 目录结构

采用 **Monorepo 最佳实践**，backend 完全自包含所有后端相关文件：

```
kortix-cli/                         # 项目根目录
├── backend/                        # 后端服务（自包含）
│   ├── .env                       # 环境变量（API Keys）
│   ├── .env.example               # 环境变量示例
│   ├── config.yaml                # 后端配置文件
│   ├── requirements.txt           # Python 依赖
│   ├── main.py                    # FastAPI 应用入口
│   ├── api/                       # API 路由模块
│   │   ├── __init__.py
│   │   ├── chat.py                # 对话接口
│   │   ├── tools.py               # 工具管理接口
│   │   ├── history.py             # 历史记录接口
│   │   ├── dependencies.py        # 依赖注入
│   │   └── models.py              # Pydantic 数据模型
│   └── core/                      # 核心业务逻辑
│       ├── agent.py               # AI Agent
│       ├── llm.py                 # LLM 调用封装
│       ├── tools/                 # 工具系统
│       │   ├── registry.py        # 工具注册表
│       │   ├── file_manager.py    # 文件管理工具
│       │   ├── web_search.py      # Web 搜索工具
│       │   ├── shell.py           # Shell 命令工具
│       │   ├── calculator.py      # 计算器工具
│       │   └── code_executor.py   # 代码执行工具
│       └── utils/                 # 工具函数
│           ├── config.py          # 配置加载
│           ├── logger.py          # 日志工具
│           └── sandbox.py         # Docker 沙箱管理
├── apps/                          # 前端应用（预留）
│   └── frontend/
│       ├── .gitkeep
│       └── README.md
├── run.py                         # CLI 启动脚本
├── start_api.py                   # API 启动脚本（唯一入口）
├── docker-compose.yaml            # Docker 编排
├── Dockerfile                     # Docker 镜像构建
└── README.md                      # 项目说明
```

**架构特点**：
- ✅ Backend 完全自包含（代码、配置、依赖、环境变量都在 `backend/` 下）
- ✅ 统一的启动入口（根目录的 `start_api.py`）
- ✅ 清晰的职责分离（backend 是后端，apps 是前端）
- ✅ 符合 Monorepo 最佳实践

---

## 配置和启动

### 环境变量配置

所有环境变量配置在 `backend/.env` 文件中：

```bash
# backend/.env
DASHSCOPE_API_KEY=sk-your-api-key-here    # 阿里云百炼 API Key（必需）
TAVILY_API_KEY=tvly-your-key              # Tavily 搜索 API Key（可选）
```

参考 `backend/.env.example` 创建自己的 `.env` 文件。

### 应用配置

主要配置在 `backend/config.yaml`：

```yaml
# LLM 配置
llm:
  provider: dashscope
  model: qwen-plus
  temperature: 0.7
  max_tokens: 2000

# 工具配置
tools:
  file_manager:
    workspace_dir: ./workspace
  web_search:
    enabled: true
    
# 其他配置...
```

### 启动方式

**启动 API 服务**（推荐从项目根目录）:
```bash
cd /path/to/kortix-cli

# 开发模式（热重载）
python start_api.py

# 生产模式（多进程）
python start_api.py --prod --workers 4

# 自定义端口
python start_api.py --port 9000
```

**启动 CLI 模式**:
```bash
python run.py
```

**Docker 部署**:
```bash
# 一键部署
bash docker-deploy.sh

# 或使用 docker-compose
docker compose up -d
```

**访问 API 文档**: http://localhost:8000/docs

---

## API 接口规范

### 基础信息
- **Base URL**: `http://localhost:8000/v1`
- **Content-Type**: `application/json`
- **请求方法**: GET, POST, DELETE

### 端点列表

#### 1. 健康检查
```http
GET /health
```

**响应**:
```json
{
  "status": "ok",
  "timestamp": "2026-02-05T16:55:40+08:00",
  "tools_enabled": ["file_manager", "web_search", "shell", "calculator", "code_executor"]
}
```

---

#### 2. 对话接口

##### 2.1 流式对话 (推荐)
```http
POST /v1/chat
Content-Type: application/json

{
  "message": "你好，帮我计算 123 * 456",
  "stream": true
}
```

**响应** (Server-Sent Events):
```
data: {"type": "content", "content": "你好"}

data: {"type": "content", "content": "！"}

data: {"type": "tool_call", "tool": "calculator", "function": "calculate", "args": {"expression": "123 * 456"}}

data: {"type": "tool_result", "success": true, "output": "56088"}

data: {"type": "content", "content": "计算结果是 56088"}

data: {"type": "done"}
```

##### 2.2 非流式对话
```http
POST /v1/chat/completion
Content-Type: application/json

{
  "message": "你好，介绍一下你的能力"
}
```

**响应**:
```json
{
  "content": "你好！我是 Kortix AI Agent...",
  "tool_calls": [],
  "timestamp": "2026-02-05T16:55:40+08:00"
}
```

##### 2.3 重置对话
```http
POST /v1/chat/reset
```

**响应**:
```json
{
  "success": true,
  "message": "对话历史已重置"
}
```

---

#### 3. 工具管理接口

##### 3.1 获取工具列表
```http
GET /v1/tools
```

**响应**:
```json
{
  "tools": [
    {
      "name": "file_manager",
      "description": "文件管理工具，支持读写编辑搜索文件",
      "functions": [
        {
          "name": "read_file",
          "description": "读取文件内容",
          "parameters": {
            "type": "object",
            "properties": {
              "filepath": {"type": "string", "description": "文件路径"}
            },
            "required": ["filepath"]
          }
        },
        {
          "name": "write_file",
          "description": "写入文件",
          "parameters": {
            "type": "object",
            "properties": {
              "filepath": {"type": "string"},
              "content": {"type": "string"}
            },
            "required": ["filepath", "content"]
          }
        }
      ]
    },
    {
      "name": "calculator",
      "description": "计算器工具",
      "functions": [
        {
          "name": "calculate",
          "description": "执行数学计算",
          "parameters": {
            "type": "object",
            "properties": {
              "expression": {"type": "string", "description": "数学表达式"}
            }
          }
        }
      ]
    }
  ]
}
```

##### 3.2 获取特定工具信息
```http
GET /v1/tools/calculator
```

**响应**:
```json
{
  "name": "calculator",
  "description": "计算器工具，支持数学计算和时间查询",
  "functions": [...]
}
```

##### 3.3 直接执行工具 (可选)
```http
POST /v1/tools/calculator/execute
Content-Type: application/json

{
  "function": "calculate",
  "parameters": {
    "expression": "sin(pi/2) + log(100)"
  }
}
```

**响应**:
```json
{
  "success": true,
  "output": "5.605170185988092",
  "error": null
}
```

---

#### 4. 对话历史管理

##### 4.1 获取对话历史
```http
GET /v1/history?limit=50
```

**响应**:
```json
{
  "messages": [
    {
      "role": "system",
      "content": "你是 Kortix AI Agent...",
      "timestamp": "2026-02-05T16:50:00+08:00"
    },
    {
      "role": "user",
      "content": "你好",
      "timestamp": "2026-02-05T16:51:00+08:00"
    },
    {
      "role": "assistant",
      "content": "你好！有什么我可以帮助你的？",
      "timestamp": "2026-02-05T16:51:01+08:00"
    }
  ],
  "total": 3
}
```

##### 4.2 保存对话历史
```http
POST /v1/history/save
```

**响应**:
```json
{
  "success": true,
  "filepath": "./conversations/conversation_20260205_165540.json"
}
```

##### 4.3 加载对话历史
```http
POST /v1/history/load
Content-Type: application/json

{
  "filepath": "./conversations/conversation_20260205_165540.json"
}
```

##### 4.4 清除对话历史
```http
DELETE /v1/history
```

---

## 数据模型

### ChatRequest
```python
class ChatRequest(BaseModel):
    message: str  # 用户消息内容
    stream: Optional[bool] = True  # 是否流式响应
```

### ChatResponse
```python
class ChatResponse(BaseModel):
    content: str  # 助手回复内容
    tool_calls: Optional[List[ToolCall]] = None  # 工具调用信息
    timestamp: str  # 响应时间戳
```

### ToolCall
```python
class ToolCall(BaseModel):
    id: str  # 工具调用 ID
    type: str = "function"
    function: FunctionCall
```

### FunctionCall
```python
class FunctionCall(BaseModel):
    name: str  # 函数名
    arguments: str  # JSON 字符串格式的参数
```

### ToolInfo
```python
class ToolInfo(BaseModel):
    name: str  # 工具名称
    description: str  # 工具描述
    functions: List[FunctionDefinition]  # 函数列表
```

### HistoryMessage
```python
class HistoryMessage(BaseModel):
    role: Literal["system", "user", "assistant", "tool"]
    content: str
    timestamp: str
    tool_calls: Optional[List[ToolCall]] = None
    tool_call_id: Optional[str] = None
    name: Optional[str] = None
```

---

## 代码风格指南

### 1. Python 代码规范
遵循 [PEP 8](https://pep8.org/) 和 [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)

#### 命名规范
- **模块名**: `lowercase_with_underscores.py`
- **类名**: `PascalCase`
- **函数名**: `lowercase_with_underscores()`
- **常量**: `UPPERCASE_WITH_UNDERSCORES`
- **私有变量/方法**: `_leading_underscore`

#### 示例
```python
# 好的例子 ✅
class ChatRouter:
    def __init__(self):
        self._agent = Agent()
    
    async def handle_chat_request(self, request: ChatRequest) -> ChatResponse:
        """处理对话请求"""
        pass

# 不好的例子 ❌
class chatRouter:  # 类名应该用 PascalCase
    def HandleChatRequest(self, req):  # 函数名应该用 snake_case
        pass
```

### 2. 类型注解
**必须**为所有公共函数添加类型注解：

```python
# 好的例子 ✅
from typing import List, Optional

async def get_tools() -> List[ToolInfo]:
    """获取所有工具信息"""
    pass

async def execute_tool(
    tool_name: str,
    function_name: str,
    parameters: dict
) -> ToolResult:
    """执行工具函数"""
    pass

# 不好的例子 ❌
async def get_tools():  # 缺少返回类型
    pass
```

### 3. 文档字符串
使用 Google 风格的 docstring：

```python
async def chat_stream(request: ChatRequest) -> StreamingResponse:
    """
    处理流式对话请求
    
    Args:
        request: 包含用户消息的请求对象
    
    Returns:
        StreamingResponse: SSE 格式的流式响应
    
    Raises:
        HTTPException: 当 Agent 初始化失败时
    
    Example:
        >>> response = await chat_stream(ChatRequest(message="你好"))
    """
    pass
```

### 4. 异步编程规范

#### 4.1 始终使用 async/await
```python
# 好的例子 ✅
async def process_message(message: str) -> str:
    result = await agent.chat_async(message)
    return result

# 不好的例子 ❌
def process_message(message: str) -> str:
    # 同步代码会阻塞事件循环
    result = agent.chat(message)
    return result
```

#### 4.2 并发处理
使用 `asyncio.gather()` 并发执行：

```python
# 并发获取多个工具信息
async def get_multiple_tools(tool_names: List[str]) -> List[ToolInfo]:
    tasks = [get_tool_info(name) for name in tool_names]
    return await asyncio.gather(*tasks)
```

### 5. 错误处理

#### 5.1 使用 HTTPException
```python
from fastapi import HTTPException, status

@router.get("/tools/{tool_name}")
async def get_tool(tool_name: str) -> ToolInfo:
    tool = tool_registry.get_tool(tool_name)
    if not tool:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"工具 '{tool_name}' 不存在"
        )
    return tool.get_info()
```

#### 5.2 全局异常处理
```python
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"未处理的异常: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": "内部服务器错误",
            "detail": str(exc) if app.debug else "请联系管理员"
        }
    )
```

### 6. 日志规范

#### 6.1 日志级别
- `DEBUG`: 详细的调试信息
- `INFO`: 一般性信息（如请求处理）
- `WARNING`: 警告信息（如弃用功能）
- `ERROR`: 错误信息（如异常捕获）

#### 6.2 日志格式
```python
from core.utils.logger import get_logger

logger = get_logger(__name__)

# 结构化日志
logger.info("处理对话请求", 
    user_message=request.message,
    stream=request.stream,
    message_count=len(agent.messages)
)

# 错误日志
logger.error("工具执行失败",
    tool=tool_name,
    function=function_name,
    error=str(e),
    exc_info=True
)
```

### 7. FastAPI 路由规范

#### 7.1 路由装饰器
```python
@router.post(
    "/chat",
    response_model=ChatResponse,
    summary="发送对话消息",
    description="发送消息给 AI Agent，支持流式和非流式响应",
    tags=["chat"]
)
async def chat(request: ChatRequest) -> ChatResponse:
    pass
```

#### 7.2 依赖注入
```python
from fastapi import Depends

async def get_agent() -> Agent:
    """依赖注入：获取 Agent 实例"""
    return global_agent

@router.post("/chat")
async def chat(
    request: ChatRequest,
    agent: Agent = Depends(get_agent)
) -> ChatResponse:
    # 使用注入的 agent
    pass
```

### 8. 响应格式规范

#### 8.1 成功响应
```python
# 标准 JSON 响应
{
    "success": true,
    "data": {...},
    "timestamp": "2026-02-05T16:55:40+08:00"
}
```

#### 8.2 错误响应
```python
# 错误响应格式
{
    "error": "工具未找到",
    "detail": "工具 'unknown_tool' 不存在",
    "timestamp": "2026-02-05T16:55:40+08:00"
}
```

#### 8.3 流式响应 (SSE)
```python
# SSE 格式
data: {"type": "content", "content": "Hello"}

data: {"type": "tool_call", "tool": "calculator", ...}

data: {"type": "done"}
```

---

## 测试规范

### 1. 单元测试
使用 `pytest` 和 `httpx`：

```python
import pytest
from httpx import AsyncClient
from api import app

@pytest.mark.asyncio
async def test_health_check():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/health")
        assert response.status_code == 200
        assert response.json()["status"] == "ok"

@pytest.mark.asyncio
async def test_chat_completion():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/v1/chat/completion",
            json={"message": "你好"}
        )
        assert response.status_code == 200
        assert "content" in response.json()
```

### 2. 集成测试
测试完整的对话流程：

```python
@pytest.mark.asyncio
async def test_chat_with_tool_call():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/v1/chat/completion",
            json={"message": "帮我计算 2 + 2"}
        )
        data = response.json()
        assert "4" in data["content"]
```

---

## 性能优化

### 1. 异步优化
- 使用 `asyncio.gather()` 并发执行
- 避免在 async 函数中使用阻塞调用
- 使用连接池管理数据库/Redis 连接

### 2. 缓存策略
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def get_tool_schema(tool_name: str) -> dict:
    """缓存工具 schema"""
    return tool_registry.get_tool(tool_name).get_schema()
```

### 3. 流式响应优化
```python
async def chat_stream(request: ChatRequest):
    async def event_generator():
        try:
            async for chunk in agent.chat_async(request.message):
                yield f"data: {json.dumps({'content': chunk})}\n\n"
                await asyncio.sleep(0)  # 让出控制权
        finally:
            # 清理资源
            pass
    
    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no"  # 禁用 nginx 缓冲
        }
    )
```

---

## 部署配置

### 1. 环境变量
```bash
# .env
DASHSCOPE_API_KEY=sk-xxxxx
TAVILY_API_KEY=tvly-xxxxx
LOG_LEVEL=INFO
WORKERS=4
```

### 2. Uvicorn 配置
```python
# start_api.py
import uvicorn

if __name__ == "__main__":
    uvicorn.run(
        "api:app",
        host="0.0.0.0",
        port=8000,
        workers=4,  # 生产环境使用多进程
        reload=False,  # 生产环境禁用热重载
        log_level="info",
        access_log=True
    )
```

### 3. Docker 部署
```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000
CMD ["python", "start_api.py"]
```

---

## 安全性

### 1. CORS 配置
```python
# 生产环境应限制具体域名
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "DELETE"],
    allow_headers=["Content-Type", "Authorization"],
)
```

### 2. 请求限流
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post("/chat")
@limiter.limit("10/minute")
async def chat(request: Request, chat_request: ChatRequest):
    pass
```

### 3. 输入验证
使用 Pydantic 自动验证：

```python
from pydantic import BaseModel, Field, validator

class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, max_length=10000)
    
    @validator("message")
    def validate_message(cls, v):
        if not v.strip():
            raise ValueError("消息不能为空")
        return v.strip()
```

---

## 附录

### A. 参考资源
- [FastAPI 官方文档](https://fastapi.tiangolo.com/)
- [Suna 项目](https://github.com/kortix-ai/suna)
- [阿里云百炼文档](https://help.aliyun.com/zh/dashscope/)

### B. 常见问题

**Q: 项目根目录有两个 start_api.py 吗？**  
A: 不，只有根目录有一个 `start_api.py`。之前 `backend/start_api.py` 已删除，避免混淆。

**Q: 如何启动 API 服务？**
```bash
# 从项目根目录启动
cd /path/to/kortix-cli
python start_api.py
```

**Q: 配置文件在哪里？**  
A: 所有配置都在 `backend/` 目录下：
- `backend/.env` - 环境变量（API Keys）
- `backend/config.yaml` - 应用配置
- `backend/requirements.txt` - Python 依赖

**Q: 如何测试流式接口？**
```bash
curl -N -X POST http://localhost:8000/v1/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "你好"}'
```

**Q: 如何查看 API 文档？**  
访问 http://localhost:8000/docs

**Q: 运行时数据保存在哪里？**  
A: 以下目录会自动创建在项目根目录：
- `conversations/` - 对话历史
- `workspace/` - AI 工作区
- `logs/` - 日志文件（如果启用）

---

**文档版本**: v2.0  
**最后更新**: 2026-02-05  
**架构**: Monorepo (Backend 自包含)  
**维护者**: Kortix Team
